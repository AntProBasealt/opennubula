{"version":3,"file":"index.js","sources":["../src/base64url.ts","../src/schema-format.ts","../src/webauthn-schema.ts","../src/webauthn.ts"],"sourcesContent":["export type Base64urlString = string;\n\nexport function base64urlToBuffer(baseurl64String: Base64urlString): ArrayBuffer {\n  // Base64url to Base64\n  const padding = \"==\".slice(0, (4 - (baseurl64String.length % 4)) % 4);\n  const base64String = baseurl64String.replace(/-/g, \"+\").replace(/_/g, \"/\") + padding;\n\n  // Base64 to binary string\n  const str = atob(base64String);\n\n  // Binary string to buffer\n  const buffer = new ArrayBuffer(str.length);\n  const byteView = new Uint8Array(buffer);\n  for (let i = 0; i < str.length; i++) {\n    byteView[i] = str.charCodeAt(i);\n  }\n  return buffer;\n}\n\nexport function bufferToBase64url(buffer: ArrayBuffer): Base64urlString {\n  // Buffer to binary string\n  const byteView = new Uint8Array(buffer);\n  let str = \"\";\n  for (const charCode of byteView) {\n    str += String.fromCharCode(charCode);\n  }\n\n  // Binary string to base64\n  const base64String = btoa(str);\n\n  // Base64 to base64url\n  // We assume that the base64url string is well-formed.\n  const base64urlString = base64String.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n  return base64urlString;\n}\n","type SchemaLeaf = \"copy\" | \"convert\";\ninterface SchemaObject { [property: string]: { required: boolean; schema: Schema; }; }\ntype SchemaArray = [SchemaObject] | [SchemaLeaf];\n\nexport type Schema = SchemaLeaf | SchemaArray | SchemaObject;\n\n// We export these values in order so that they can be used to deduplicate\n// schema definitions in minified JS code.\nexport const copyValue = \"copy\";\nexport const convertValue = \"convert\";\n\nexport function convert<From, To>(conversionFn: (v: From) => To, schema: Schema, input: any): any {\n  if (schema === copyValue) {\n    return input;\n  }\n  if (schema === convertValue) {\n    return conversionFn(input);\n  }\n  if (schema instanceof Array) {\n    return input.map((v: any) => convert<From, To>(conversionFn, schema[0], v));\n  }\n  if (schema instanceof Object) {\n    const output: any = {};\n    for (const [key, schemaField] of Object.entries(schema)) {\n      if (!(key in input)) {\n        if (schemaField.required) {\n          throw new Error(`Missing key: ${key}`);\n        }\n        continue;\n      }\n      // Fields can be null (rather than missing or `undefined`), e.g. the\n      // `userHandle` field of the `AuthenticatorAssertionResponse`:\n      // https://www.w3.org/TR/webauthn/#iface-authenticatorassertionresponse\n      if (input[key] == null) {\n        output[key] = null;\n        continue;\n      }\n      output[key] = convert<From, To>(conversionFn, schemaField.schema, input[key]);\n    }\n    return output;\n  }\n}\n\nexport function required(schema: Schema): any {\n  return {\n    required: true,\n    schema,\n  };\n}\n\nexport function optional(schema: Schema): any {\n  return {\n    required: false,\n    schema,\n  };\n}\n","import { convertValue as convert, copyValue as copy, optional, required, Schema } from \"./schema-format\";\n\n// Shared by `create()` and `get()`.\n\nconst publicKeyCredentialDescriptorSchema: Schema = {\n  type: required(copy),\n  id: required(convert),\n  transports: optional(copy),\n};\n\nconst extensionsSchema: Schema = {\n  appid: optional(copy),\n  txAuthSimple: optional(copy),\n  txAuthGeneric: optional({\n    contentType: required(copy),\n    content: required(convert),\n  }),\n  authnSel: optional([convert]),\n  exts: optional(copy),\n  uvi: optional(copy),\n  loc: optional(copy),\n  uvm: optional(copy),\n  authenticatorBiometricPerfBounds: optional(copy),\n};\n\n// `navigator.create()` request\n\nexport const credentialCreationOptions: Schema = {\n  publicKey: required({\n    rp: required(copy),\n    user: required({\n      id: required(convert),\n      name: required(copy),\n      displayName: required(copy),\n      icon: optional(copy),\n    }),\n\n    challenge: required(convert),\n    pubKeyCredParams: required(copy),\n\n    timeout: optional(copy),\n    excludeCredentials: optional([publicKeyCredentialDescriptorSchema]),\n    authenticatorSelection: optional(copy),\n    attestation: optional(copy),\n    extensions: optional(extensionsSchema),\n  }),\n  signal: optional(copy),\n};\n\n// `navigator.create()` response\n\nexport const publicKeyCredentialWithAttestation: Schema = {\n  type: required(copy),\n  id: required(copy),\n  rawId: required(convert),\n  response: required({\n    clientDataJSON: required(convert),\n    attestationObject: required(convert),\n  }),\n};\n\n// `navigator.get()` request\n\nexport const credentialRequestOptions: Schema = {\n  mediation: optional(copy),\n  publicKey: required({\n    challenge: required(convert),\n    timeout: optional(copy),\n    rpId: optional(copy),\n    allowCredentials: optional([publicKeyCredentialDescriptorSchema]),\n    userVerification: optional(copy),\n    extensions: optional(extensionsSchema),\n  }),\n  signal: optional(copy),\n};\n\n// `navigator.get()` response\n\nexport const publicKeyCredentialWithAssertion: Schema = {\n  type: required(copy),\n  id: required(copy),\n  rawId: required(convert),\n  response: required({\n    clientDataJSON: required(convert),\n    authenticatorData: required(convert),\n    signature: required(convert),\n    userHandle: required(convert),\n  }),\n};\n\nexport const schema: { [s: string]: Schema } = {\n  credentialCreationOptions,\n  publicKeyCredentialWithAttestation,\n  credentialRequestOptions,\n  publicKeyCredentialWithAssertion,\n};\n","import { base64urlToBuffer, bufferToBase64url } from \"./base64url\";\nimport { CredentialCreationOptionsJSON, CredentialRequestOptionsJSON, PublicKeyCredentialWithAssertionJSON, PublicKeyCredentialWithAttestationJSON } from \"./json\";\nimport { convert } from \"./schema-format\";\nimport { credentialCreationOptions, credentialRequestOptions, publicKeyCredentialWithAssertion, publicKeyCredentialWithAttestation } from \"./webauthn-schema\";\n\nexport async function create(requestJSON: CredentialCreationOptionsJSON): Promise<PublicKeyCredentialWithAttestationJSON> {\n  const request = convert(base64urlToBuffer, credentialCreationOptions, requestJSON);\n  const credential = (await navigator.credentials.create(request)) as PublicKeyCredential;\n  const responseJSON = convert(bufferToBase64url, publicKeyCredentialWithAttestation, credential);\n  responseJSON.clientExtensionResults = credential.getClientExtensionResults();\n  return responseJSON;\n}\n\nexport async function get(requestJSON: CredentialRequestOptionsJSON): Promise<PublicKeyCredentialWithAssertionJSON> {\n  const request = convert(base64urlToBuffer, credentialRequestOptions, requestJSON);\n  const response = (await navigator.credentials.get(request)) as PublicKeyCredential;\n  const responseJSON = convert(bufferToBase64url, publicKeyCredentialWithAssertion, response);\n  responseJSON.clientExtensionResults = response.getClientExtensionResults();\n  return responseJSON;\n}\n\ndeclare global {\n  interface Window {\n    PublicKeyCredential: PublicKeyCredential | undefined;\n  }\n}\n\n// This function does a simple check to test for the credential management API\n// functions we need, and an indication of public key credential authentication\n// support.\n// https://developers.google.com/web/updates/2018/03/webauthn-credential-management\nexport function supported(): boolean {\n  return !!(navigator.credentials && navigator.credentials.create && navigator.credentials.get && window.PublicKeyCredential);\n}\n"],"names":["base64urlToBuffer","baseurl64String","padding","slice","length","base64String","replace","str","atob","buffer","ArrayBuffer","byteView","Uint8Array","i","charCodeAt","bufferToBase64url","charCode","String","fromCharCode","btoa","copyValue","convertValue","convert","conversionFn","schema","input","Array","map","v","Object","output","key","schemaField","entries","required","Error","optional","publicKeyCredentialDescriptorSchema","type","copy","id","transports","extensionsSchema","appid","txAuthSimple","txAuthGeneric","contentType","content","authnSel","exts","uvi","loc","uvm","authenticatorBiometricPerfBounds","credentialCreationOptions","publicKey","rp","user","name","displayName","icon","challenge","pubKeyCredParams","timeout","excludeCredentials","authenticatorSelection","attestation","extensions","signal","publicKeyCredentialWithAttestation","rawId","response","clientDataJSON","attestationObject","credentialRequestOptions","mediation","rpId","allowCredentials","userVerification","publicKeyCredentialWithAssertion","authenticatorData","signature","userHandle","async","requestJSON","request","credential","navigator","credentials","create","responseJSON","clientExtensionResults","getClientExtensionResults","get","window","PublicKeyCredential"],"mappings":"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"}